<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>(转)字符串是否包含问题 | Hadnot&#39;s blog</title>
  <meta name="author" content="hongtaozhy">
  
  <meta name="description" content="blog,ios,cpp,程序员,工作,objective-c,oc">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="(转)字符串是否包含问题"/>
  <meta property="og:site_name" content="Hadnot&#39;s blog"/>

  
    <meta property="og:image" content="undefined"/>
  
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="Hadnot&#39;s blog" type="application/atom+xml">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <!--  -->
  
  <link rel="stylesheet" href="/css/prettify_raytaylorism.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css?ver=3" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/duoshuo_style.css?ver=4" media="screen" type="text/css">
  
  <script type="text/javascript" src="/js/prettify.js"></script>
  <script type="text/javascript" src="/js/jquery-2.0.3.min.js"></script>
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hadnot&#39;s blog</a></h1>
  <h2><a href="/">www.hongtaozhy.com</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">存档</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-01-24T02:15:18.000Z"><a href="/2014/01/24/string1/">1月 24 2014</a></time>
      
      
  
    <h1 class="title">(转)字符串是否包含问题</h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/edit/master/ebook/zh/02.0.md" target="_blank">本文引用自此</a></p>
</blockquote>
<h2 id="-">字符串是否包含问题</h2>
<h3 id="-">题目描述</h3>
<p>假设这有两个分别由字母组成的字符串A另外字符串B，字符串B的字母数较字符串A少一些。什么方法能最快地查出字符串B所有字母是不是都在字符串A里？也就是说判断字符串B是不是字符串A的真子集（为了简化，姑且认为两个集合都不是空集，即字符串都不为空。）。为了简单起见，我们规定输入的字符串只包含大写英文字母。</p>
<p>实现函数bool compare(string &amp;A,string &amp;B)</p>
<p>比如，如果是下面两个字符串：</p>
<p>String 1: ABCDEFGHLMNOPQRS</p>
<p>String 2: DCGSRQPO</p>
<p>答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。</p>
<p>如果是下面两个字符串：</p>
<p>String 1: ABCDEFGHLMNOPQRS</p>
<p>String 2: DCGSRQPZ</p>
<p>答案是false，因为字符串String2里的Z字母不在字符串String1里。</p>
<p>点评：</p>
<ol>
<li><p>题目描述虽长，但题意很明了，就是给定一长一短的两个字符串A，B，假设A长B短，要求判断B是否包含在字符串A中，即B?(-A。</p>
</li>
<li><p>似乎简单，但实现起来并不轻松，且如果面试官步步紧逼，一个一个否决你能想到的方法，要你给出更好、最好的方案时，恐怕就要伤不少脑筋了。</p>
</li>
</ol>
<p>在揭晓答案之前，读者最好先想一想，看看自己能想到的最好方案是什么，是否与本文作者所见略同。</p>
<h3 id="-">解法一、暴力轮询</h3>
<p><a id="more"></a>
判断string2中的字符是否在string1中?：</p>
<p>String 1: ABCDEFGHLMNOPQRS</p>
<p>String 2: DCGSRQPO</p>
<p>最直观也是最简单的思路是，针对string2中每一个字符，一一与string1中每个字符依次轮询比较，看它是否在String1中。</p>
<p>代码可如下编写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="comment">//copyright@caopengcs 2013-01-14</span>
<span class="keyword">bool</span> compare(<span class="built_in">string</span> &a,<span class="built_in">string</span> &b)
{
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); ++i) {
        <span class="keyword">int</span> j;
        <span class="keyword">for</span> (j = <span class="number">0</span>; (j &lt; a.length()) && (a[j] != b[i]); ++j)
            ;
        <span class="keyword">if</span> (j &gt;= a.length())
        {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<p>假设n是字符串String1的长度，m是字符串String2的长度，那么此算法，需要O（n<em>m）次操作，以上面的例子来说，将会有16</em>8 = 128次操作。显然，时间开销太大，应该找到一种更好的办法。</p>
<h3 id="-">解法二、普通排序</h3>
<p>一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。</p>
<p>同样拿上面的字串做例子，将会需要16<em>4 + 8</em>3 = 88，再加上对两个字串线性扫描的16 + 8 = 24的操作。(随着字串长度的增长，你会发现这个算法的效果会越来越好)</p>
<p>关于排序方法，可采用最常用的快速排序，C有库函数qsort,C++有库函数sort，排序不是重点，因此使用库函数好一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">//copyright@caopengcs 2014-01-14 </span>
<span class="comment">//注意A B中可能包含重复字符，所以注意A下标不要轻易移动。这种方法改变了字符串。如不想改变请自己复制</span>
<span class="keyword">bool</span> compare(<span class="built_in">string</span> &a,<span class="built_in">string</span> &b)
{
    sort(a.begin(),a.end());
    sort(b.begin(),b.end());
    <span class="keyword">for</span> (<span class="keyword">int</span> pa = <span class="number">0</span>, pb = <span class="number">0</span>; pb &lt; b.length();)
    {
        <span class="keyword">while</span> ((pa &lt; a.length()) && (a[pa] &lt; b[pb]))
        {
            ++pa;
        }
        <span class="keyword">if</span> ((pa &gt;= a.length()) || (a[pa] &gt; b[pb]))
        {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="comment">//a[pa] == b[pb]</span>
        ++pb;
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<h3 id="-">解法三、计数比较</h3>
<p>此方案与上述相比，区别在于不用排序。采用线性时间的计数方法，假设需要比较字符串A（n）中是否包含字符串B（m），统计A中出现的字符O(n)，比较B中是否有出现的字符O(m)，总计时间复杂度为：O(n+m)。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">// copyright@caopengcs 2014-01-14</span>
<span class="comment">// modified by @古道西风 2014-01-14</span>
<span class="keyword">bool</span> compare(<span class="built_in">string</span> &a,<span class="built_in">string</span> &b)
{
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> have;
    have.resize(<span class="number">26</span>,<span class="number">0</span>);
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)
    {
        ++have[a[i] - <span class="string">'A'</span>];
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); ++i)
    {
        <span class="comment">//若A中只需要包含同一个相同的字符即可代表B中重复出现的字符</span>
        <span class="comment">//即A：CDEFAB	B：AABBCC 合法</span>
        <span class="keyword">if</span> (have[b[i] - <span class="string">'A'</span>] == <span class="number">0</span>)
        {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        <span class="comment">//若A中需要包含B中所有重复出现字符</span>
        <span class="comment">//即A：AAACCDBBCCE	B：AABBCC 合法</span>
        <span class="comment">//即A：BCDEFA	B：AABBCC 非法</span>
        <span class="comment">//if (have[b[i] - 'A']-- == 0) {</span>
        <span class="comment">//	return false;</span>
        <span class="comment">//}</span>
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<h3 id="-hashtable">解法四、巧用hashtable</h3>
<p>上述方案中，较好的方法是先对字符串进行排序，然后再线性扫描，总的时间已经优化到了：O(m+n)，貌似到了极限，还有没有更好的办法?</p>
<p>可以对短字符串进行轮询（此思路的叙述可能与网上的一些叙述有出入。最好是把短的先存储，那样，会降低时间复杂度），把其中的每个字母都放入一个Hashtable里（始终设m为短字符串的长度，那么此项操作成本是O(m)或8次操作）。然后轮询长字符串，在Hashtable里查询短字符串的每个字符，看能否找到。如果找不到，说明没有匹配成功，轮询长字符串将消耗掉16次操作，这样两项操作加起来一共只有8+16=24次。</p>
<p>当然，理想情况是如果长字串的前缀就为短字串，只需消耗8次操作，这样总共只需8+8=16次。</p>
<p>或如梦想天窗所说： 我之前用散列表做过一次，算法如下：</p>
<ol>
<li>hash[26]，先全部清零，然后扫描短的字符串，若有相应的置1，</li>
<li>计算hash[26]中1的个数，记为m</li>
<li>扫描长字符串的每个字符a；若原来hash[a] == 1 ，则修改hash[a] = 0，并将m减1；若hash[a] == 0，则不做处理</li>
<li>若m == 0 or 扫描结束，退出循环。</li>
</ol>
<p>这种方法其实和1.3节方法类似。</p>
<p>代码实现，也不难，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">// copyright@caopengcs 2014-01-14</span>
<span class="keyword">bool</span> compare(<span class="built_in">string</span> &a,<span class="built_in">string</span> &b)
{
    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> hash;
    hash.resize(<span class="number">26</span>,<span class="number">0</span>);
    <span class="keyword">int</span> m = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); ++i)
    {
        <span class="keyword">int</span> x = b[i] - <span class="string">'A'</span>;
        <span class="keyword">if</span> (hash[x] == <span class="number">0</span>)
        {
            hash[x] = <span class="number">1</span>;
            ++m;
        }
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)
    {
        <span class="keyword">int</span> x = a[i] - <span class="string">'A'</span>;
        <span class="keyword">if</span> (hash[x] == <span class="number">1</span>)
        {
            --m;
            hash[x] = <span class="number">0</span>;
        }
    }
    <span class="keyword">return</span> m == <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<h3 id="-">解法五、素数相乘</h3>
<p>继续追问，还有更好的方案么?</p>
<p>或许想到：O(n+m)已经是能得到的最好结果了，对每个字母至少访问一次才能完成这项操作，而前述的后两个方案是刚好是对每个字母只访问一次。</p>
<p>ok，下面给出的方案更让人思路大开：</p>
<p>假设有一个仅由字母组成字串，让每个每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。</p>
<p>利用上面字母和素数的对应关系，对应第二个字符串中的字母，然后轮询，用每个字母对应的素数除前面得到的整数。如果结果有余数，说明结果为false。如果整个过程中没有余数，则说明第二个字符串是第一个的子集了（判断是不是真子集，可以比较两个字符串对应的素数乘积，若相等则不是真子集）。</p>
<p>思路总结如下：</p>
<ol>
<li>按照从小到大的顺序，用26个素数分别与字符&#39;A&#39;到&#39;Z&#39;一一对应。</li>
<li>遍历长字符串，求得每个字符对应素数的乘积。</li>
<li>遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。</li>
<li>输出结果。</li>
</ol>
<p>如前所述，算法的时间复杂度为O(m+n)的最好的情况为O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回false），n为长字串的长度，空间复杂度为O(1)。</p>
<p>不过，正如原文中所述：“现在我想告诉你 —— Guy的方案在算法上并不能说就比我的好。而且在实际操作中，你很可能仍会使用我的方案，因为它更通用，无需跟麻烦的大型数字打交道。但从”巧妙水平“上讲，Guy提供的是一种更、更、更有趣的方案。”</p>
<p>ok，如果你有更好的思路，欢迎在本文的评论中给出，非常感谢。</p>
<p>这种方法的缺点是可能整数溢出……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">// copyright@caopengcs </span>
<span class="comment">//此方法只有理论意义，因为整数乘积很大，有溢出风险</span>
<span class="keyword">bool</span> compare(<span class="built_in">string</span> &a,<span class="built_in">string</span> &b)
{
    <span class="keyword">const</span> <span class="keyword">int</span> p[<span class="number">26</span>] = {<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>,<span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>};
    <span class="keyword">int</span> f = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)
    {
        <span class="keyword">int</span> x = p[a[i] - <span class="string">'A'</span>];
        <span class="keyword">if</span> (f % x)
        {
            f *= x;
        }
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); ++i)
    {
        <span class="keyword">int</span> x = p[b[i] - <span class="string">'A'</span>];
        <span class="keyword">if</span> (f % x)
        {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>

<h3 id="-">解法六、位运算</h3>
<p>最好的思路是对字符串A,用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。这个方法的实质是用一个整数代替了hashtable，空间复杂度可以降低为O(1)。时间复杂度还是O(n + m)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">// copyright@caopengcs </span>
<span class="comment">// “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)</span>
<span class="keyword">bool</span> compare(<span class="built_in">string</span> &a,<span class="built_in">string</span> &b)
{
    <span class="keyword">int</span> hash = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); ++i)
    {
        hash |= (<span class="number">1</span> &lt;&lt; (a[i] - <span class="string">'A'</span>));
    }
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length(); ++i)
    {
        <span class="keyword">if</span> ((hash & (<span class="number">1</span> &lt;&lt; (b[i] - <span class="string">'A'</span>))) == <span class="number">0</span>)
        {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/算法/">算法</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/算法/">算法</a>, <a href="/tags/字符串/">字符串</a>, <a href="/tags/分享/">分享</a>
  </div>

<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a><a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=86835285.js?cdnversion='+~(-new Date()/36e5)];</script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <!-- Duoshuo Comment BEGIN -->
  	<div class="ds-thread"></div>
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"hongtaozhy"};
  	(function() {
  		var ds = document.createElement('script');
  		ds.type = 'text/javascript';ds.async = true;
  		ds.src = 'http://static.duoshuo.com/embed.js';
  		ds.charset = 'UTF-8';
  		(document.getElementsByTagName('head')[0] 
  		|| document.getElementsByTagName('body')[0]).appendChild(ds);
  	})();
  	</script>
  <!-- Duoshuo Comment END -->
</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:www.hongtaozhy.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Tips/">Tips</a><small>4</small></li>
  
    <li><a href="/categories/iOS/">iOS</a><small>3</small></li>
  
    <li><a href="/categories/markdown/">markdown</a><small>1</small></li>
  
    <li><a href="/categories/人生/">人生</a><small>2</small></li>
  
    <li><a href="/categories/算法/">算法</a><small>1</small></li>
  
  </ul>
</div>


  <iframe width="100%" height="650" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=650&fansRow=3&ptype=1&speed=50&skin=4&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=2033686914&verifier=e0a18d12&dpc=1"></iframe>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2014/03/10/use_instancetype/">正确的使用instancetype代替id</a>
      </li>
    
      <li>
        <a href="/2014/02/19/provisioning/">Provisioning文件的存放地址</a>
      </li>
    
      <li>
        <a href="/2014/01/29/tools/">总结下最近用的工具</a>
      </li>
    
      <li>
        <a href="/2014/01/28/ios7_chrome/">推荐一个Chrome扩展</a>
      </li>
    
      <li>
        <a href="/2014/01/24/string1/">(转)字符串是否包含问题</a>
      </li>
    
  </ul>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://www.cppblog.com/wicbnu" title="从零开始"></a>wicbnu</li>
<li><a href="http://woyaowenzi.github.io/" title="WOYAOWENZI's blog">WOYAOWENZI's blog</a></li>
<li><a href="http://huangliangjie.gitcafe.com/" title="Liangjie's hexo site">Liangjie's hexo site</a></li>
<li><a href="http://waysnotes.com/" title="WaysNotes">WaysNotes</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 hongtaozhy
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        $("code").addClass("prettyprint");
        
        prettyPrint();
    });
</script>  




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>